# Conway-s-Game-of-Life-Project

###Video Demo: https://youtu.be/sCjneGqbD_w 

###Description:

A simulation of Conway's Game of Life. Conway's Game of Life is a fascinating zero-player game created by British mathematician John Horton Conway in 1970. 
It's a cellular automaton, where an infinite grid of cells can be either "alive" or "dead," and their states evolve over time based on simple rules. These rules determine how cells change from one generation to the next: a living cell with two or three living neighbors survives, while fewer or more causes it to die; a dead cell with exactly three living neighbors becomes alive. 
Despite the simplicity of these rules, the Game of Life can produce incredibly complex, often chaotic, and even seemingly intelligent patterns, demonstrating how intricate behavior can emerge from simple systems. It has become a significant subject of study in mathematics, computer science, and artificial life, and remains popular for visualizing emergent systems and self-replicating patterns.

	This game has always interested me ever since I heard about it. Cellular automata fascinates me, and I thought this would be a great opportunity to try to program it myself. 
My first prototypes for this project were made with Python. I switched to HTML, JavaScript and CSS because I wanted it to be more web-based. The website.html file is where the bulk of the work is. I first wanted to understand how the logic behind the game worked. I needed to create a grid of cells, each with a value of either one or zero.  Depending on the values of the surrounding cells, and the value of the cell itself, the value would either change or stay the same in the next state. This logic was simple enough; I used a double nested array for the grid of values, and getting the values of the surrounding neighbors was just getting the sum of the neighbors using loops. I wanted the cells to be small,  but still visible and clickable to the viewer, as the simulation looks best when there are many cells, but you can still see each one. I then needed to actually animate the game. After I got that down, I worked on the code for manipulating the simulation (The buttons and the ability to set any cell as living or dead). I was experimenting with different grid sizes. The grid size I had for most of the development of the project was a 30 by 30 grid. I thought that this was a little small, so I increased the dimensions until I settled for 65 by 65.

	One design decision I had to make was on handling edge-cases. I could have either treated the edge of the grid like a real edge, as in the cell values for the that would be past the edge would always be zero. Or, I could have “wrapped the edges”. Essentially, the grid acts as if the edges wrap around each other, so the cells at the top edge of the grid would treat the cells at the bottom edge in the same column as neighboring cells, and vice-versa. I chose the later option, because I didn’t really want the simulation and the values of the cell to be limited by just grid size. 

Of course, another feature I wanted to add to my version is the ability to directly decide what cells are living and dead by clicking on the cells and changing their state. I wanted to implement this because I wanted to give the user complete control over the state of the game, and choose which patterns they wanted to work with. 

Other very important features that needed to be added were the buttons used to manipulate the game, so the “start”, “pause”, and “Restart/Create Random Grid”. Not only were these important for the final design, they were important for fixing errors and writing the code. Another design choice that was helpful for trouble-shooting was the population value. Not only is it good for the user to see how many cells are alive and the general trends of the population, it was also helpful for me to see if the population value reflected what was actually on the grid while writing the program. I also included a slider that allows you to control the animation speed, from one fps to 60 fps, so you could see in better or smoother detail how the simulation progresses. 

The styles.css file is the CSS component of the project. It’s rather modest, and that’s because I thought that the most important part of the project was the game itself. I didn’t think it necessary to spend much time developing an extravagant webpage. I changed the font for the title because it would be fitting, but I kept the page mostly simple. 

Overall, I thought it was a largely successful project. I was able to implement pretty much all of my desired features of the game, and it works as expected. I thought it was a pretty good learning experience.
